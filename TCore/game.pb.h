// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: game.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_game_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_game_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "error.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_game_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_game_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_game_2eproto;
namespace gamepb {
class C2SGobangStep;
struct C2SGobangStepDefaultTypeInternal;
extern C2SGobangStepDefaultTypeInternal _C2SGobangStep_default_instance_;
class C2SPing;
struct C2SPingDefaultTypeInternal;
extern C2SPingDefaultTypeInternal _C2SPing_default_instance_;
class ChessStep;
struct ChessStepDefaultTypeInternal;
extern ChessStepDefaultTypeInternal _ChessStep_default_instance_;
class Error;
struct ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class GobangInfo;
struct GobangInfoDefaultTypeInternal;
extern GobangInfoDefaultTypeInternal _GobangInfo_default_instance_;
class HelloReply;
struct HelloReplyDefaultTypeInternal;
extern HelloReplyDefaultTypeInternal _HelloReply_default_instance_;
class HelloRequest;
struct HelloRequestDefaultTypeInternal;
extern HelloRequestDefaultTypeInternal _HelloRequest_default_instance_;
class Point;
struct PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class RouteNote;
struct RouteNoteDefaultTypeInternal;
extern RouteNoteDefaultTypeInternal _RouteNote_default_instance_;
class S2CGobangStep;
struct S2CGobangStepDefaultTypeInternal;
extern S2CGobangStepDefaultTypeInternal _S2CGobangStep_default_instance_;
class S2CPing;
struct S2CPingDefaultTypeInternal;
extern S2CPingDefaultTypeInternal _S2CPing_default_instance_;
}  // namespace gamepb
PROTOBUF_NAMESPACE_OPEN
template<> ::gamepb::C2SGobangStep* Arena::CreateMaybeMessage<::gamepb::C2SGobangStep>(Arena*);
template<> ::gamepb::C2SPing* Arena::CreateMaybeMessage<::gamepb::C2SPing>(Arena*);
template<> ::gamepb::ChessStep* Arena::CreateMaybeMessage<::gamepb::ChessStep>(Arena*);
template<> ::gamepb::Error* Arena::CreateMaybeMessage<::gamepb::Error>(Arena*);
template<> ::gamepb::GobangInfo* Arena::CreateMaybeMessage<::gamepb::GobangInfo>(Arena*);
template<> ::gamepb::HelloReply* Arena::CreateMaybeMessage<::gamepb::HelloReply>(Arena*);
template<> ::gamepb::HelloRequest* Arena::CreateMaybeMessage<::gamepb::HelloRequest>(Arena*);
template<> ::gamepb::Point* Arena::CreateMaybeMessage<::gamepb::Point>(Arena*);
template<> ::gamepb::RouteNote* Arena::CreateMaybeMessage<::gamepb::RouteNote>(Arena*);
template<> ::gamepb::S2CGobangStep* Arena::CreateMaybeMessage<::gamepb::S2CGobangStep>(Arena*);
template<> ::gamepb::S2CPing* Arena::CreateMaybeMessage<::gamepb::S2CPing>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace gamepb {

// ===================================================================

class HelloRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gamepb.HelloRequest) */ {
 public:
  inline HelloRequest() : HelloRequest(nullptr) {}
  ~HelloRequest() override;
  explicit constexpr HelloRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HelloRequest(const HelloRequest& from);
  HelloRequest(HelloRequest&& from) noexcept
    : HelloRequest() {
    *this = ::std::move(from);
  }

  inline HelloRequest& operator=(const HelloRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloRequest& operator=(HelloRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HelloRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HelloRequest* internal_default_instance() {
    return reinterpret_cast<const HelloRequest*>(
               &_HelloRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(HelloRequest& a, HelloRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HelloRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HelloRequest* New() const final {
    return new HelloRequest();
  }

  HelloRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HelloRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HelloRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HelloRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gamepb.HelloRequest";
  }
  protected:
  explicit HelloRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:gamepb.HelloRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class HelloReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gamepb.HelloReply) */ {
 public:
  inline HelloReply() : HelloReply(nullptr) {}
  ~HelloReply() override;
  explicit constexpr HelloReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HelloReply(const HelloReply& from);
  HelloReply(HelloReply&& from) noexcept
    : HelloReply() {
    *this = ::std::move(from);
  }

  inline HelloReply& operator=(const HelloReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloReply& operator=(HelloReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HelloReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const HelloReply* internal_default_instance() {
    return reinterpret_cast<const HelloReply*>(
               &_HelloReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(HelloReply& a, HelloReply& b) {
    a.Swap(&b);
  }
  inline void Swap(HelloReply* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HelloReply* New() const final {
    return new HelloReply();
  }

  HelloReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HelloReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HelloReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HelloReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gamepb.HelloReply";
  }
  protected:
  explicit HelloReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:gamepb.HelloReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class RouteNote final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gamepb.RouteNote) */ {
 public:
  inline RouteNote() : RouteNote(nullptr) {}
  ~RouteNote() override;
  explicit constexpr RouteNote(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteNote(const RouteNote& from);
  RouteNote(RouteNote&& from) noexcept
    : RouteNote() {
    *this = ::std::move(from);
  }

  inline RouteNote& operator=(const RouteNote& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteNote& operator=(RouteNote&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteNote& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteNote* internal_default_instance() {
    return reinterpret_cast<const RouteNote*>(
               &_RouteNote_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RouteNote& a, RouteNote& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteNote* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteNote* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RouteNote* New() const final {
    return new RouteNote();
  }

  RouteNote* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RouteNote>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouteNote& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RouteNote& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteNote* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gamepb.RouteNote";
  }
  protected:
  explicit RouteNote(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kLocationFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .gamepb.Point location = 1;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::gamepb::Point& location() const;
  PROTOBUF_MUST_USE_RESULT ::gamepb::Point* release_location();
  ::gamepb::Point* mutable_location();
  void set_allocated_location(::gamepb::Point* location);
  private:
  const ::gamepb::Point& _internal_location() const;
  ::gamepb::Point* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::gamepb::Point* location);
  ::gamepb::Point* unsafe_arena_release_location();

  // @@protoc_insertion_point(class_scope:gamepb.RouteNote)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::gamepb::Point* location_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class Error final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gamepb.Error) */ {
 public:
  inline Error() : Error(nullptr) {}
  ~Error() override;
  explicit constexpr Error(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Error(const Error& from);
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline Error& operator=(Error&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Error& default_instance() {
    return *internal_default_instance();
  }
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }
  inline void Swap(Error* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Error* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Error* New() const final {
    return new Error();
  }

  Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Error& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Error& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gamepb.Error";
  }
  protected:
  explicit Error(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMsgFieldNumber = 2,
    kErrorCodeFieldNumber = 1,
  };
  // string errorMsg = 2;
  void clear_errormsg();
  const std::string& errormsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormsg();
  PROTOBUF_MUST_USE_RESULT std::string* release_errormsg();
  void set_allocated_errormsg(std::string* errormsg);
  private:
  const std::string& _internal_errormsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormsg(const std::string& value);
  std::string* _internal_mutable_errormsg();
  public:

  // .gamepb.ErrorType errorCode = 1;
  void clear_errorcode();
  ::gamepb::ErrorType errorcode() const;
  void set_errorcode(::gamepb::ErrorType value);
  private:
  ::gamepb::ErrorType _internal_errorcode() const;
  void _internal_set_errorcode(::gamepb::ErrorType value);
  public:

  // @@protoc_insertion_point(class_scope:gamepb.Error)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormsg_;
  int errorcode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class Point final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gamepb.Point) */ {
 public:
  inline Point() : Point(nullptr) {}
  ~Point() override;
  explicit constexpr Point(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Point(const Point& from);
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point& operator=(Point&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }
  inline void Swap(Point* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Point* New() const final {
    return new Point();
  }

  Point* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Point>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Point& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Point& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gamepb.Point";
  }
  protected:
  explicit Point(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kCampFieldNumber = 3,
  };
  // int32 x = 1;
  void clear_x();
  ::PROTOBUF_NAMESPACE_ID::int32 x() const;
  void set_x(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_x() const;
  void _internal_set_x(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 y = 2;
  void clear_y();
  ::PROTOBUF_NAMESPACE_ID::int32 y() const;
  void set_y(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_y() const;
  void _internal_set_y(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 Camp = 3;
  void clear_camp();
  ::PROTOBUF_NAMESPACE_ID::int32 camp() const;
  void set_camp(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_camp() const;
  void _internal_set_camp(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:gamepb.Point)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 x_;
  ::PROTOBUF_NAMESPACE_ID::int32 y_;
  ::PROTOBUF_NAMESPACE_ID::int32 camp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class ChessStep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gamepb.ChessStep) */ {
 public:
  inline ChessStep() : ChessStep(nullptr) {}
  ~ChessStep() override;
  explicit constexpr ChessStep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChessStep(const ChessStep& from);
  ChessStep(ChessStep&& from) noexcept
    : ChessStep() {
    *this = ::std::move(from);
  }

  inline ChessStep& operator=(const ChessStep& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChessStep& operator=(ChessStep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChessStep& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChessStep* internal_default_instance() {
    return reinterpret_cast<const ChessStep*>(
               &_ChessStep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ChessStep& a, ChessStep& b) {
    a.Swap(&b);
  }
  inline void Swap(ChessStep* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChessStep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChessStep* New() const final {
    return new ChessStep();
  }

  ChessStep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChessStep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChessStep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChessStep& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChessStep* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gamepb.ChessStep";
  }
  protected:
  explicit ChessStep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 1,
    kIndexFieldNumber = 2,
  };
  // .gamepb.Point point = 1;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  const ::gamepb::Point& point() const;
  PROTOBUF_MUST_USE_RESULT ::gamepb::Point* release_point();
  ::gamepb::Point* mutable_point();
  void set_allocated_point(::gamepb::Point* point);
  private:
  const ::gamepb::Point& _internal_point() const;
  ::gamepb::Point* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::gamepb::Point* point);
  ::gamepb::Point* unsafe_arena_release_point();

  // int32 index = 2;
  void clear_index();
  ::PROTOBUF_NAMESPACE_ID::int32 index() const;
  void set_index(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_index() const;
  void _internal_set_index(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:gamepb.ChessStep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::gamepb::Point* point_;
  ::PROTOBUF_NAMESPACE_ID::int32 index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class GobangInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gamepb.GobangInfo) */ {
 public:
  inline GobangInfo() : GobangInfo(nullptr) {}
  ~GobangInfo() override;
  explicit constexpr GobangInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GobangInfo(const GobangInfo& from);
  GobangInfo(GobangInfo&& from) noexcept
    : GobangInfo() {
    *this = ::std::move(from);
  }

  inline GobangInfo& operator=(const GobangInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GobangInfo& operator=(GobangInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GobangInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GobangInfo* internal_default_instance() {
    return reinterpret_cast<const GobangInfo*>(
               &_GobangInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GobangInfo& a, GobangInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GobangInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GobangInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GobangInfo* New() const final {
    return new GobangInfo();
  }

  GobangInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GobangInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GobangInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GobangInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GobangInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gamepb.GobangInfo";
  }
  protected:
  explicit GobangInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChessStepsFieldNumber = 1,
  };
  // repeated .gamepb.ChessStep chessSteps = 1;
  int chesssteps_size() const;
  private:
  int _internal_chesssteps_size() const;
  public:
  void clear_chesssteps();
  ::gamepb::ChessStep* mutable_chesssteps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gamepb::ChessStep >*
      mutable_chesssteps();
  private:
  const ::gamepb::ChessStep& _internal_chesssteps(int index) const;
  ::gamepb::ChessStep* _internal_add_chesssteps();
  public:
  const ::gamepb::ChessStep& chesssteps(int index) const;
  ::gamepb::ChessStep* add_chesssteps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gamepb::ChessStep >&
      chesssteps() const;

  // @@protoc_insertion_point(class_scope:gamepb.GobangInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gamepb::ChessStep > chesssteps_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class C2SGobangStep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gamepb.C2SGobangStep) */ {
 public:
  inline C2SGobangStep() : C2SGobangStep(nullptr) {}
  ~C2SGobangStep() override;
  explicit constexpr C2SGobangStep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C2SGobangStep(const C2SGobangStep& from);
  C2SGobangStep(C2SGobangStep&& from) noexcept
    : C2SGobangStep() {
    *this = ::std::move(from);
  }

  inline C2SGobangStep& operator=(const C2SGobangStep& from) {
    CopyFrom(from);
    return *this;
  }
  inline C2SGobangStep& operator=(C2SGobangStep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C2SGobangStep& default_instance() {
    return *internal_default_instance();
  }
  static inline const C2SGobangStep* internal_default_instance() {
    return reinterpret_cast<const C2SGobangStep*>(
               &_C2SGobangStep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(C2SGobangStep& a, C2SGobangStep& b) {
    a.Swap(&b);
  }
  inline void Swap(C2SGobangStep* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C2SGobangStep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C2SGobangStep* New() const final {
    return new C2SGobangStep();
  }

  C2SGobangStep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C2SGobangStep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C2SGobangStep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C2SGobangStep& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C2SGobangStep* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gamepb.C2SGobangStep";
  }
  protected:
  explicit C2SGobangStep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 1,
  };
  // .gamepb.Point point = 1;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  const ::gamepb::Point& point() const;
  PROTOBUF_MUST_USE_RESULT ::gamepb::Point* release_point();
  ::gamepb::Point* mutable_point();
  void set_allocated_point(::gamepb::Point* point);
  private:
  const ::gamepb::Point& _internal_point() const;
  ::gamepb::Point* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::gamepb::Point* point);
  ::gamepb::Point* unsafe_arena_release_point();

  // @@protoc_insertion_point(class_scope:gamepb.C2SGobangStep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::gamepb::Point* point_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class S2CGobangStep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gamepb.S2CGobangStep) */ {
 public:
  inline S2CGobangStep() : S2CGobangStep(nullptr) {}
  ~S2CGobangStep() override;
  explicit constexpr S2CGobangStep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S2CGobangStep(const S2CGobangStep& from);
  S2CGobangStep(S2CGobangStep&& from) noexcept
    : S2CGobangStep() {
    *this = ::std::move(from);
  }

  inline S2CGobangStep& operator=(const S2CGobangStep& from) {
    CopyFrom(from);
    return *this;
  }
  inline S2CGobangStep& operator=(S2CGobangStep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S2CGobangStep& default_instance() {
    return *internal_default_instance();
  }
  static inline const S2CGobangStep* internal_default_instance() {
    return reinterpret_cast<const S2CGobangStep*>(
               &_S2CGobangStep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(S2CGobangStep& a, S2CGobangStep& b) {
    a.Swap(&b);
  }
  inline void Swap(S2CGobangStep* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S2CGobangStep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S2CGobangStep* New() const final {
    return new S2CGobangStep();
  }

  S2CGobangStep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S2CGobangStep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S2CGobangStep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S2CGobangStep& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S2CGobangStep* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gamepb.S2CGobangStep";
  }
  protected:
  explicit S2CGobangStep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kGobangInfoFieldNumber = 2,
  };
  // .gamepb.Error error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::gamepb::Error& error() const;
  PROTOBUF_MUST_USE_RESULT ::gamepb::Error* release_error();
  ::gamepb::Error* mutable_error();
  void set_allocated_error(::gamepb::Error* error);
  private:
  const ::gamepb::Error& _internal_error() const;
  ::gamepb::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::gamepb::Error* error);
  ::gamepb::Error* unsafe_arena_release_error();

  // .gamepb.GobangInfo gobangInfo = 2;
  bool has_gobanginfo() const;
  private:
  bool _internal_has_gobanginfo() const;
  public:
  void clear_gobanginfo();
  const ::gamepb::GobangInfo& gobanginfo() const;
  PROTOBUF_MUST_USE_RESULT ::gamepb::GobangInfo* release_gobanginfo();
  ::gamepb::GobangInfo* mutable_gobanginfo();
  void set_allocated_gobanginfo(::gamepb::GobangInfo* gobanginfo);
  private:
  const ::gamepb::GobangInfo& _internal_gobanginfo() const;
  ::gamepb::GobangInfo* _internal_mutable_gobanginfo();
  public:
  void unsafe_arena_set_allocated_gobanginfo(
      ::gamepb::GobangInfo* gobanginfo);
  ::gamepb::GobangInfo* unsafe_arena_release_gobanginfo();

  // @@protoc_insertion_point(class_scope:gamepb.S2CGobangStep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::gamepb::Error* error_;
  ::gamepb::GobangInfo* gobanginfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class C2SPing final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gamepb.C2SPing) */ {
 public:
  inline C2SPing() : C2SPing(nullptr) {}
  ~C2SPing() override;
  explicit constexpr C2SPing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C2SPing(const C2SPing& from);
  C2SPing(C2SPing&& from) noexcept
    : C2SPing() {
    *this = ::std::move(from);
  }

  inline C2SPing& operator=(const C2SPing& from) {
    CopyFrom(from);
    return *this;
  }
  inline C2SPing& operator=(C2SPing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C2SPing& default_instance() {
    return *internal_default_instance();
  }
  static inline const C2SPing* internal_default_instance() {
    return reinterpret_cast<const C2SPing*>(
               &_C2SPing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(C2SPing& a, C2SPing& b) {
    a.Swap(&b);
  }
  inline void Swap(C2SPing* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C2SPing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline C2SPing* New() const final {
    return new C2SPing();
  }

  C2SPing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<C2SPing>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C2SPing& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const C2SPing& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C2SPing* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gamepb.C2SPing";
  }
  protected:
  explicit C2SPing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
  };
  // int64 timestamp = 1;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:gamepb.C2SPing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class S2CPing final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gamepb.S2CPing) */ {
 public:
  inline S2CPing() : S2CPing(nullptr) {}
  ~S2CPing() override;
  explicit constexpr S2CPing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S2CPing(const S2CPing& from);
  S2CPing(S2CPing&& from) noexcept
    : S2CPing() {
    *this = ::std::move(from);
  }

  inline S2CPing& operator=(const S2CPing& from) {
    CopyFrom(from);
    return *this;
  }
  inline S2CPing& operator=(S2CPing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S2CPing& default_instance() {
    return *internal_default_instance();
  }
  static inline const S2CPing* internal_default_instance() {
    return reinterpret_cast<const S2CPing*>(
               &_S2CPing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(S2CPing& a, S2CPing& b) {
    a.Swap(&b);
  }
  inline void Swap(S2CPing* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S2CPing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline S2CPing* New() const final {
    return new S2CPing();
  }

  S2CPing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<S2CPing>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S2CPing& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S2CPing& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S2CPing* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gamepb.S2CPing";
  }
  protected:
  explicit S2CPing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // .gamepb.Error error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::gamepb::Error& error() const;
  PROTOBUF_MUST_USE_RESULT ::gamepb::Error* release_error();
  ::gamepb::Error* mutable_error();
  void set_allocated_error(::gamepb::Error* error);
  private:
  const ::gamepb::Error& _internal_error() const;
  ::gamepb::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::gamepb::Error* error);
  ::gamepb::Error* unsafe_arena_release_error();

  // int64 timestamp = 2;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:gamepb.S2CPing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::gamepb::Error* error_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_game_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HelloRequest

// string name = 1;
inline void HelloRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& HelloRequest::name() const {
  // @@protoc_insertion_point(field_get:gamepb.HelloRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HelloRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gamepb.HelloRequest.name)
}
inline std::string* HelloRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gamepb.HelloRequest.name)
  return _s;
}
inline const std::string& HelloRequest::_internal_name() const {
  return name_.Get();
}
inline void HelloRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* HelloRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* HelloRequest::release_name() {
  // @@protoc_insertion_point(field_release:gamepb.HelloRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void HelloRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:gamepb.HelloRequest.name)
}

// -------------------------------------------------------------------

// HelloReply

// string message = 1;
inline void HelloReply::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& HelloReply::message() const {
  // @@protoc_insertion_point(field_get:gamepb.HelloReply.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HelloReply::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gamepb.HelloReply.message)
}
inline std::string* HelloReply::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:gamepb.HelloReply.message)
  return _s;
}
inline const std::string& HelloReply::_internal_message() const {
  return message_.Get();
}
inline void HelloReply::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* HelloReply::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* HelloReply::release_message() {
  // @@protoc_insertion_point(field_release:gamepb.HelloReply.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void HelloReply::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:gamepb.HelloReply.message)
}

// -------------------------------------------------------------------

// RouteNote

// .gamepb.Point location = 1;
inline bool RouteNote::_internal_has_location() const {
  return this != internal_default_instance() && location_ != nullptr;
}
inline bool RouteNote::has_location() const {
  return _internal_has_location();
}
inline void RouteNote::clear_location() {
  if (GetArenaForAllocation() == nullptr && location_ != nullptr) {
    delete location_;
  }
  location_ = nullptr;
}
inline const ::gamepb::Point& RouteNote::_internal_location() const {
  const ::gamepb::Point* p = location_;
  return p != nullptr ? *p : reinterpret_cast<const ::gamepb::Point&>(
      ::gamepb::_Point_default_instance_);
}
inline const ::gamepb::Point& RouteNote::location() const {
  // @@protoc_insertion_point(field_get:gamepb.RouteNote.location)
  return _internal_location();
}
inline void RouteNote::unsafe_arena_set_allocated_location(
    ::gamepb::Point* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location_);
  }
  location_ = location;
  if (location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gamepb.RouteNote.location)
}
inline ::gamepb::Point* RouteNote::release_location() {
  
  ::gamepb::Point* temp = location_;
  location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gamepb::Point* RouteNote::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:gamepb.RouteNote.location)
  
  ::gamepb::Point* temp = location_;
  location_ = nullptr;
  return temp;
}
inline ::gamepb::Point* RouteNote::_internal_mutable_location() {
  
  if (location_ == nullptr) {
    auto* p = CreateMaybeMessage<::gamepb::Point>(GetArenaForAllocation());
    location_ = p;
  }
  return location_;
}
inline ::gamepb::Point* RouteNote::mutable_location() {
  ::gamepb::Point* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:gamepb.RouteNote.location)
  return _msg;
}
inline void RouteNote::set_allocated_location(::gamepb::Point* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::gamepb::Point>::GetOwningArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:gamepb.RouteNote.location)
}

// string message = 2;
inline void RouteNote::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& RouteNote::message() const {
  // @@protoc_insertion_point(field_get:gamepb.RouteNote.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RouteNote::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gamepb.RouteNote.message)
}
inline std::string* RouteNote::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:gamepb.RouteNote.message)
  return _s;
}
inline const std::string& RouteNote::_internal_message() const {
  return message_.Get();
}
inline void RouteNote::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RouteNote::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RouteNote::release_message() {
  // @@protoc_insertion_point(field_release:gamepb.RouteNote.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RouteNote::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:gamepb.RouteNote.message)
}

// -------------------------------------------------------------------

// Error

// .gamepb.ErrorType errorCode = 1;
inline void Error::clear_errorcode() {
  errorcode_ = 0;
}
inline ::gamepb::ErrorType Error::_internal_errorcode() const {
  return static_cast< ::gamepb::ErrorType >(errorcode_);
}
inline ::gamepb::ErrorType Error::errorcode() const {
  // @@protoc_insertion_point(field_get:gamepb.Error.errorCode)
  return _internal_errorcode();
}
inline void Error::_internal_set_errorcode(::gamepb::ErrorType value) {
  
  errorcode_ = value;
}
inline void Error::set_errorcode(::gamepb::ErrorType value) {
  _internal_set_errorcode(value);
  // @@protoc_insertion_point(field_set:gamepb.Error.errorCode)
}

// string errorMsg = 2;
inline void Error::clear_errormsg() {
  errormsg_.ClearToEmpty();
}
inline const std::string& Error::errormsg() const {
  // @@protoc_insertion_point(field_get:gamepb.Error.errorMsg)
  return _internal_errormsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Error::set_errormsg(ArgT0&& arg0, ArgT... args) {
 
 errormsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gamepb.Error.errorMsg)
}
inline std::string* Error::mutable_errormsg() {
  std::string* _s = _internal_mutable_errormsg();
  // @@protoc_insertion_point(field_mutable:gamepb.Error.errorMsg)
  return _s;
}
inline const std::string& Error::_internal_errormsg() const {
  return errormsg_.Get();
}
inline void Error::_internal_set_errormsg(const std::string& value) {
  
  errormsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Error::_internal_mutable_errormsg() {
  
  return errormsg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Error::release_errormsg() {
  // @@protoc_insertion_point(field_release:gamepb.Error.errorMsg)
  return errormsg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Error::set_allocated_errormsg(std::string* errormsg) {
  if (errormsg != nullptr) {
    
  } else {
    
  }
  errormsg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errormsg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:gamepb.Error.errorMsg)
}

// -------------------------------------------------------------------

// Point

// int32 x = 1;
inline void Point::clear_x() {
  x_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Point::_internal_x() const {
  return x_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Point::x() const {
  // @@protoc_insertion_point(field_get:gamepb.Point.x)
  return _internal_x();
}
inline void Point::_internal_set_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  x_ = value;
}
inline void Point::set_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:gamepb.Point.x)
}

// int32 y = 2;
inline void Point::clear_y() {
  y_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Point::_internal_y() const {
  return y_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Point::y() const {
  // @@protoc_insertion_point(field_get:gamepb.Point.y)
  return _internal_y();
}
inline void Point::_internal_set_y(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  y_ = value;
}
inline void Point::set_y(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:gamepb.Point.y)
}

// int32 Camp = 3;
inline void Point::clear_camp() {
  camp_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Point::_internal_camp() const {
  return camp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Point::camp() const {
  // @@protoc_insertion_point(field_get:gamepb.Point.Camp)
  return _internal_camp();
}
inline void Point::_internal_set_camp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  camp_ = value;
}
inline void Point::set_camp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_camp(value);
  // @@protoc_insertion_point(field_set:gamepb.Point.Camp)
}

// -------------------------------------------------------------------

// ChessStep

// .gamepb.Point point = 1;
inline bool ChessStep::_internal_has_point() const {
  return this != internal_default_instance() && point_ != nullptr;
}
inline bool ChessStep::has_point() const {
  return _internal_has_point();
}
inline void ChessStep::clear_point() {
  if (GetArenaForAllocation() == nullptr && point_ != nullptr) {
    delete point_;
  }
  point_ = nullptr;
}
inline const ::gamepb::Point& ChessStep::_internal_point() const {
  const ::gamepb::Point* p = point_;
  return p != nullptr ? *p : reinterpret_cast<const ::gamepb::Point&>(
      ::gamepb::_Point_default_instance_);
}
inline const ::gamepb::Point& ChessStep::point() const {
  // @@protoc_insertion_point(field_get:gamepb.ChessStep.point)
  return _internal_point();
}
inline void ChessStep::unsafe_arena_set_allocated_point(
    ::gamepb::Point* point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_);
  }
  point_ = point;
  if (point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gamepb.ChessStep.point)
}
inline ::gamepb::Point* ChessStep::release_point() {
  
  ::gamepb::Point* temp = point_;
  point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gamepb::Point* ChessStep::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:gamepb.ChessStep.point)
  
  ::gamepb::Point* temp = point_;
  point_ = nullptr;
  return temp;
}
inline ::gamepb::Point* ChessStep::_internal_mutable_point() {
  
  if (point_ == nullptr) {
    auto* p = CreateMaybeMessage<::gamepb::Point>(GetArenaForAllocation());
    point_ = p;
  }
  return point_;
}
inline ::gamepb::Point* ChessStep::mutable_point() {
  ::gamepb::Point* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:gamepb.ChessStep.point)
  return _msg;
}
inline void ChessStep::set_allocated_point(::gamepb::Point* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete point_;
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::gamepb::Point>::GetOwningArena(point);
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    
  } else {
    
  }
  point_ = point;
  // @@protoc_insertion_point(field_set_allocated:gamepb.ChessStep.point)
}

// int32 index = 2;
inline void ChessStep::clear_index() {
  index_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChessStep::_internal_index() const {
  return index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChessStep::index() const {
  // @@protoc_insertion_point(field_get:gamepb.ChessStep.index)
  return _internal_index();
}
inline void ChessStep::_internal_set_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  index_ = value;
}
inline void ChessStep::set_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:gamepb.ChessStep.index)
}

// -------------------------------------------------------------------

// GobangInfo

// repeated .gamepb.ChessStep chessSteps = 1;
inline int GobangInfo::_internal_chesssteps_size() const {
  return chesssteps_.size();
}
inline int GobangInfo::chesssteps_size() const {
  return _internal_chesssteps_size();
}
inline void GobangInfo::clear_chesssteps() {
  chesssteps_.Clear();
}
inline ::gamepb::ChessStep* GobangInfo::mutable_chesssteps(int index) {
  // @@protoc_insertion_point(field_mutable:gamepb.GobangInfo.chessSteps)
  return chesssteps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gamepb::ChessStep >*
GobangInfo::mutable_chesssteps() {
  // @@protoc_insertion_point(field_mutable_list:gamepb.GobangInfo.chessSteps)
  return &chesssteps_;
}
inline const ::gamepb::ChessStep& GobangInfo::_internal_chesssteps(int index) const {
  return chesssteps_.Get(index);
}
inline const ::gamepb::ChessStep& GobangInfo::chesssteps(int index) const {
  // @@protoc_insertion_point(field_get:gamepb.GobangInfo.chessSteps)
  return _internal_chesssteps(index);
}
inline ::gamepb::ChessStep* GobangInfo::_internal_add_chesssteps() {
  return chesssteps_.Add();
}
inline ::gamepb::ChessStep* GobangInfo::add_chesssteps() {
  ::gamepb::ChessStep* _add = _internal_add_chesssteps();
  // @@protoc_insertion_point(field_add:gamepb.GobangInfo.chessSteps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gamepb::ChessStep >&
GobangInfo::chesssteps() const {
  // @@protoc_insertion_point(field_list:gamepb.GobangInfo.chessSteps)
  return chesssteps_;
}

// -------------------------------------------------------------------

// C2SGobangStep

// .gamepb.Point point = 1;
inline bool C2SGobangStep::_internal_has_point() const {
  return this != internal_default_instance() && point_ != nullptr;
}
inline bool C2SGobangStep::has_point() const {
  return _internal_has_point();
}
inline void C2SGobangStep::clear_point() {
  if (GetArenaForAllocation() == nullptr && point_ != nullptr) {
    delete point_;
  }
  point_ = nullptr;
}
inline const ::gamepb::Point& C2SGobangStep::_internal_point() const {
  const ::gamepb::Point* p = point_;
  return p != nullptr ? *p : reinterpret_cast<const ::gamepb::Point&>(
      ::gamepb::_Point_default_instance_);
}
inline const ::gamepb::Point& C2SGobangStep::point() const {
  // @@protoc_insertion_point(field_get:gamepb.C2SGobangStep.point)
  return _internal_point();
}
inline void C2SGobangStep::unsafe_arena_set_allocated_point(
    ::gamepb::Point* point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_);
  }
  point_ = point;
  if (point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gamepb.C2SGobangStep.point)
}
inline ::gamepb::Point* C2SGobangStep::release_point() {
  
  ::gamepb::Point* temp = point_;
  point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gamepb::Point* C2SGobangStep::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:gamepb.C2SGobangStep.point)
  
  ::gamepb::Point* temp = point_;
  point_ = nullptr;
  return temp;
}
inline ::gamepb::Point* C2SGobangStep::_internal_mutable_point() {
  
  if (point_ == nullptr) {
    auto* p = CreateMaybeMessage<::gamepb::Point>(GetArenaForAllocation());
    point_ = p;
  }
  return point_;
}
inline ::gamepb::Point* C2SGobangStep::mutable_point() {
  ::gamepb::Point* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:gamepb.C2SGobangStep.point)
  return _msg;
}
inline void C2SGobangStep::set_allocated_point(::gamepb::Point* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete point_;
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::gamepb::Point>::GetOwningArena(point);
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    
  } else {
    
  }
  point_ = point;
  // @@protoc_insertion_point(field_set_allocated:gamepb.C2SGobangStep.point)
}

// -------------------------------------------------------------------

// S2CGobangStep

// .gamepb.Error error = 1;
inline bool S2CGobangStep::_internal_has_error() const {
  return this != internal_default_instance() && error_ != nullptr;
}
inline bool S2CGobangStep::has_error() const {
  return _internal_has_error();
}
inline void S2CGobangStep::clear_error() {
  if (GetArenaForAllocation() == nullptr && error_ != nullptr) {
    delete error_;
  }
  error_ = nullptr;
}
inline const ::gamepb::Error& S2CGobangStep::_internal_error() const {
  const ::gamepb::Error* p = error_;
  return p != nullptr ? *p : reinterpret_cast<const ::gamepb::Error&>(
      ::gamepb::_Error_default_instance_);
}
inline const ::gamepb::Error& S2CGobangStep::error() const {
  // @@protoc_insertion_point(field_get:gamepb.S2CGobangStep.error)
  return _internal_error();
}
inline void S2CGobangStep::unsafe_arena_set_allocated_error(
    ::gamepb::Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_);
  }
  error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gamepb.S2CGobangStep.error)
}
inline ::gamepb::Error* S2CGobangStep::release_error() {
  
  ::gamepb::Error* temp = error_;
  error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gamepb::Error* S2CGobangStep::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:gamepb.S2CGobangStep.error)
  
  ::gamepb::Error* temp = error_;
  error_ = nullptr;
  return temp;
}
inline ::gamepb::Error* S2CGobangStep::_internal_mutable_error() {
  
  if (error_ == nullptr) {
    auto* p = CreateMaybeMessage<::gamepb::Error>(GetArenaForAllocation());
    error_ = p;
  }
  return error_;
}
inline ::gamepb::Error* S2CGobangStep::mutable_error() {
  ::gamepb::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:gamepb.S2CGobangStep.error)
  return _msg;
}
inline void S2CGobangStep::set_allocated_error(::gamepb::Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::gamepb::Error>::GetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:gamepb.S2CGobangStep.error)
}

// .gamepb.GobangInfo gobangInfo = 2;
inline bool S2CGobangStep::_internal_has_gobanginfo() const {
  return this != internal_default_instance() && gobanginfo_ != nullptr;
}
inline bool S2CGobangStep::has_gobanginfo() const {
  return _internal_has_gobanginfo();
}
inline void S2CGobangStep::clear_gobanginfo() {
  if (GetArenaForAllocation() == nullptr && gobanginfo_ != nullptr) {
    delete gobanginfo_;
  }
  gobanginfo_ = nullptr;
}
inline const ::gamepb::GobangInfo& S2CGobangStep::_internal_gobanginfo() const {
  const ::gamepb::GobangInfo* p = gobanginfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::gamepb::GobangInfo&>(
      ::gamepb::_GobangInfo_default_instance_);
}
inline const ::gamepb::GobangInfo& S2CGobangStep::gobanginfo() const {
  // @@protoc_insertion_point(field_get:gamepb.S2CGobangStep.gobangInfo)
  return _internal_gobanginfo();
}
inline void S2CGobangStep::unsafe_arena_set_allocated_gobanginfo(
    ::gamepb::GobangInfo* gobanginfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gobanginfo_);
  }
  gobanginfo_ = gobanginfo;
  if (gobanginfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gamepb.S2CGobangStep.gobangInfo)
}
inline ::gamepb::GobangInfo* S2CGobangStep::release_gobanginfo() {
  
  ::gamepb::GobangInfo* temp = gobanginfo_;
  gobanginfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gamepb::GobangInfo* S2CGobangStep::unsafe_arena_release_gobanginfo() {
  // @@protoc_insertion_point(field_release:gamepb.S2CGobangStep.gobangInfo)
  
  ::gamepb::GobangInfo* temp = gobanginfo_;
  gobanginfo_ = nullptr;
  return temp;
}
inline ::gamepb::GobangInfo* S2CGobangStep::_internal_mutable_gobanginfo() {
  
  if (gobanginfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::gamepb::GobangInfo>(GetArenaForAllocation());
    gobanginfo_ = p;
  }
  return gobanginfo_;
}
inline ::gamepb::GobangInfo* S2CGobangStep::mutable_gobanginfo() {
  ::gamepb::GobangInfo* _msg = _internal_mutable_gobanginfo();
  // @@protoc_insertion_point(field_mutable:gamepb.S2CGobangStep.gobangInfo)
  return _msg;
}
inline void S2CGobangStep::set_allocated_gobanginfo(::gamepb::GobangInfo* gobanginfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gobanginfo_;
  }
  if (gobanginfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::gamepb::GobangInfo>::GetOwningArena(gobanginfo);
    if (message_arena != submessage_arena) {
      gobanginfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gobanginfo, submessage_arena);
    }
    
  } else {
    
  }
  gobanginfo_ = gobanginfo;
  // @@protoc_insertion_point(field_set_allocated:gamepb.S2CGobangStep.gobangInfo)
}

// -------------------------------------------------------------------

// C2SPing

// int64 timestamp = 1;
inline void C2SPing::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 C2SPing::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 C2SPing::timestamp() const {
  // @@protoc_insertion_point(field_get:gamepb.C2SPing.timestamp)
  return _internal_timestamp();
}
inline void C2SPing::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  timestamp_ = value;
}
inline void C2SPing::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:gamepb.C2SPing.timestamp)
}

// -------------------------------------------------------------------

// S2CPing

// .gamepb.Error error = 1;
inline bool S2CPing::_internal_has_error() const {
  return this != internal_default_instance() && error_ != nullptr;
}
inline bool S2CPing::has_error() const {
  return _internal_has_error();
}
inline void S2CPing::clear_error() {
  if (GetArenaForAllocation() == nullptr && error_ != nullptr) {
    delete error_;
  }
  error_ = nullptr;
}
inline const ::gamepb::Error& S2CPing::_internal_error() const {
  const ::gamepb::Error* p = error_;
  return p != nullptr ? *p : reinterpret_cast<const ::gamepb::Error&>(
      ::gamepb::_Error_default_instance_);
}
inline const ::gamepb::Error& S2CPing::error() const {
  // @@protoc_insertion_point(field_get:gamepb.S2CPing.error)
  return _internal_error();
}
inline void S2CPing::unsafe_arena_set_allocated_error(
    ::gamepb::Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_);
  }
  error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gamepb.S2CPing.error)
}
inline ::gamepb::Error* S2CPing::release_error() {
  
  ::gamepb::Error* temp = error_;
  error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gamepb::Error* S2CPing::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:gamepb.S2CPing.error)
  
  ::gamepb::Error* temp = error_;
  error_ = nullptr;
  return temp;
}
inline ::gamepb::Error* S2CPing::_internal_mutable_error() {
  
  if (error_ == nullptr) {
    auto* p = CreateMaybeMessage<::gamepb::Error>(GetArenaForAllocation());
    error_ = p;
  }
  return error_;
}
inline ::gamepb::Error* S2CPing::mutable_error() {
  ::gamepb::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:gamepb.S2CPing.error)
  return _msg;
}
inline void S2CPing::set_allocated_error(::gamepb::Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::gamepb::Error>::GetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:gamepb.S2CPing.error)
}

// int64 timestamp = 2;
inline void S2CPing::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 S2CPing::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 S2CPing::timestamp() const {
  // @@protoc_insertion_point(field_get:gamepb.S2CPing.timestamp)
  return _internal_timestamp();
}
inline void S2CPing::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  timestamp_ = value;
}
inline void S2CPing::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:gamepb.S2CPing.timestamp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace gamepb

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_game_2eproto
