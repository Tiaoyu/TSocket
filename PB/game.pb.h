// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: game.proto

#ifndef PROTOBUF_game_2eproto__INCLUDED
#define PROTOBUF_game_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "error.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_game_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[11];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsHelloRequestImpl();
void InitDefaultsHelloRequest();
void InitDefaultsHelloReplyImpl();
void InitDefaultsHelloReply();
void InitDefaultsRouteNoteImpl();
void InitDefaultsRouteNote();
void InitDefaultsErrorImpl();
void InitDefaultsError();
void InitDefaultsPointImpl();
void InitDefaultsPoint();
void InitDefaultsChessStepImpl();
void InitDefaultsChessStep();
void InitDefaultsGobangInfoImpl();
void InitDefaultsGobangInfo();
void InitDefaultsC2SGobangStepImpl();
void InitDefaultsC2SGobangStep();
void InitDefaultsS2CGobangStepImpl();
void InitDefaultsS2CGobangStep();
void InitDefaultsC2SPingImpl();
void InitDefaultsC2SPing();
void InitDefaultsS2CPingImpl();
void InitDefaultsS2CPing();
inline void InitDefaults() {
  InitDefaultsHelloRequest();
  InitDefaultsHelloReply();
  InitDefaultsRouteNote();
  InitDefaultsError();
  InitDefaultsPoint();
  InitDefaultsChessStep();
  InitDefaultsGobangInfo();
  InitDefaultsC2SGobangStep();
  InitDefaultsS2CGobangStep();
  InitDefaultsC2SPing();
  InitDefaultsS2CPing();
}
}  // namespace protobuf_game_2eproto
namespace gamepb {
class C2SGobangStep;
class C2SGobangStepDefaultTypeInternal;
extern C2SGobangStepDefaultTypeInternal _C2SGobangStep_default_instance_;
class C2SPing;
class C2SPingDefaultTypeInternal;
extern C2SPingDefaultTypeInternal _C2SPing_default_instance_;
class ChessStep;
class ChessStepDefaultTypeInternal;
extern ChessStepDefaultTypeInternal _ChessStep_default_instance_;
class Error;
class ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class GobangInfo;
class GobangInfoDefaultTypeInternal;
extern GobangInfoDefaultTypeInternal _GobangInfo_default_instance_;
class HelloReply;
class HelloReplyDefaultTypeInternal;
extern HelloReplyDefaultTypeInternal _HelloReply_default_instance_;
class HelloRequest;
class HelloRequestDefaultTypeInternal;
extern HelloRequestDefaultTypeInternal _HelloRequest_default_instance_;
class Point;
class PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class RouteNote;
class RouteNoteDefaultTypeInternal;
extern RouteNoteDefaultTypeInternal _RouteNote_default_instance_;
class S2CGobangStep;
class S2CGobangStepDefaultTypeInternal;
extern S2CGobangStepDefaultTypeInternal _S2CGobangStep_default_instance_;
class S2CPing;
class S2CPingDefaultTypeInternal;
extern S2CPingDefaultTypeInternal _S2CPing_default_instance_;
}  // namespace gamepb
namespace gamepb {

// ===================================================================

class HelloRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gamepb.HelloRequest) */ {
 public:
  HelloRequest();
  virtual ~HelloRequest();

  HelloRequest(const HelloRequest& from);

  inline HelloRequest& operator=(const HelloRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HelloRequest(HelloRequest&& from) noexcept
    : HelloRequest() {
    *this = ::std::move(from);
  }

  inline HelloRequest& operator=(HelloRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HelloRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HelloRequest* internal_default_instance() {
    return reinterpret_cast<const HelloRequest*>(
               &_HelloRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(HelloRequest* other);
  friend void swap(HelloRequest& a, HelloRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HelloRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  HelloRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HelloRequest& from);
  void MergeFrom(const HelloRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HelloRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:gamepb.HelloRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsHelloRequestImpl();
};
// -------------------------------------------------------------------

class HelloReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gamepb.HelloReply) */ {
 public:
  HelloReply();
  virtual ~HelloReply();

  HelloReply(const HelloReply& from);

  inline HelloReply& operator=(const HelloReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HelloReply(HelloReply&& from) noexcept
    : HelloReply() {
    *this = ::std::move(from);
  }

  inline HelloReply& operator=(HelloReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HelloReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HelloReply* internal_default_instance() {
    return reinterpret_cast<const HelloReply*>(
               &_HelloReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(HelloReply* other);
  friend void swap(HelloReply& a, HelloReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HelloReply* New() const PROTOBUF_FINAL { return New(NULL); }

  HelloReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HelloReply& from);
  void MergeFrom(const HelloReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HelloReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 1;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:gamepb.HelloReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsHelloReplyImpl();
};
// -------------------------------------------------------------------

class RouteNote : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gamepb.RouteNote) */ {
 public:
  RouteNote();
  virtual ~RouteNote();

  RouteNote(const RouteNote& from);

  inline RouteNote& operator=(const RouteNote& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RouteNote(RouteNote&& from) noexcept
    : RouteNote() {
    *this = ::std::move(from);
  }

  inline RouteNote& operator=(RouteNote&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RouteNote& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RouteNote* internal_default_instance() {
    return reinterpret_cast<const RouteNote*>(
               &_RouteNote_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(RouteNote* other);
  friend void swap(RouteNote& a, RouteNote& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RouteNote* New() const PROTOBUF_FINAL { return New(NULL); }

  RouteNote* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RouteNote& from);
  void MergeFrom(const RouteNote& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RouteNote* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // .gamepb.Point location = 1;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::gamepb::Point& location() const;
  ::gamepb::Point* release_location();
  ::gamepb::Point* mutable_location();
  void set_allocated_location(::gamepb::Point* location);

  // @@protoc_insertion_point(class_scope:gamepb.RouteNote)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::gamepb::Point* location_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsRouteNoteImpl();
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gamepb.Error) */ {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(Error&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Error* other);
  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error* New() const PROTOBUF_FINAL { return New(NULL); }

  Error* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Error* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string errorMsg = 2;
  void clear_errormsg();
  static const int kErrorMsgFieldNumber = 2;
  const ::std::string& errormsg() const;
  void set_errormsg(const ::std::string& value);
  #if LANG_CXX11
  void set_errormsg(::std::string&& value);
  #endif
  void set_errormsg(const char* value);
  void set_errormsg(const char* value, size_t size);
  ::std::string* mutable_errormsg();
  ::std::string* release_errormsg();
  void set_allocated_errormsg(::std::string* errormsg);

  // .gamepb.ErrorType errorCode = 1;
  void clear_errorcode();
  static const int kErrorCodeFieldNumber = 1;
  ::gamepb::ErrorType errorcode() const;
  void set_errorcode(::gamepb::ErrorType value);

  // @@protoc_insertion_point(class_scope:gamepb.Error)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr errormsg_;
  int errorcode_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsErrorImpl();
};
// -------------------------------------------------------------------

class Point : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gamepb.Point) */ {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(Point&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Point* other);
  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Point* New() const PROTOBUF_FINAL { return New(NULL); }

  Point* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Point* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // int32 y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // int32 Camp = 3;
  void clear_camp();
  static const int kCampFieldNumber = 3;
  ::google::protobuf::int32 camp() const;
  void set_camp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:gamepb.Point)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 camp_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsPointImpl();
};
// -------------------------------------------------------------------

class ChessStep : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gamepb.ChessStep) */ {
 public:
  ChessStep();
  virtual ~ChessStep();

  ChessStep(const ChessStep& from);

  inline ChessStep& operator=(const ChessStep& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChessStep(ChessStep&& from) noexcept
    : ChessStep() {
    *this = ::std::move(from);
  }

  inline ChessStep& operator=(ChessStep&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChessStep& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChessStep* internal_default_instance() {
    return reinterpret_cast<const ChessStep*>(
               &_ChessStep_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ChessStep* other);
  friend void swap(ChessStep& a, ChessStep& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChessStep* New() const PROTOBUF_FINAL { return New(NULL); }

  ChessStep* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChessStep& from);
  void MergeFrom(const ChessStep& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChessStep* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .gamepb.Point point = 1;
  bool has_point() const;
  void clear_point();
  static const int kPointFieldNumber = 1;
  const ::gamepb::Point& point() const;
  ::gamepb::Point* release_point();
  ::gamepb::Point* mutable_point();
  void set_allocated_point(::gamepb::Point* point);

  // int32 index = 2;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:gamepb.ChessStep)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::gamepb::Point* point_;
  ::google::protobuf::int32 index_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsChessStepImpl();
};
// -------------------------------------------------------------------

class GobangInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gamepb.GobangInfo) */ {
 public:
  GobangInfo();
  virtual ~GobangInfo();

  GobangInfo(const GobangInfo& from);

  inline GobangInfo& operator=(const GobangInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GobangInfo(GobangInfo&& from) noexcept
    : GobangInfo() {
    *this = ::std::move(from);
  }

  inline GobangInfo& operator=(GobangInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GobangInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GobangInfo* internal_default_instance() {
    return reinterpret_cast<const GobangInfo*>(
               &_GobangInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(GobangInfo* other);
  friend void swap(GobangInfo& a, GobangInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GobangInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  GobangInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GobangInfo& from);
  void MergeFrom(const GobangInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GobangInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .gamepb.ChessStep chessSteps = 1;
  int chesssteps_size() const;
  void clear_chesssteps();
  static const int kChessStepsFieldNumber = 1;
  const ::gamepb::ChessStep& chesssteps(int index) const;
  ::gamepb::ChessStep* mutable_chesssteps(int index);
  ::gamepb::ChessStep* add_chesssteps();
  ::google::protobuf::RepeatedPtrField< ::gamepb::ChessStep >*
      mutable_chesssteps();
  const ::google::protobuf::RepeatedPtrField< ::gamepb::ChessStep >&
      chesssteps() const;

  // @@protoc_insertion_point(class_scope:gamepb.GobangInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::gamepb::ChessStep > chesssteps_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsGobangInfoImpl();
};
// -------------------------------------------------------------------

class C2SGobangStep : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gamepb.C2SGobangStep) */ {
 public:
  C2SGobangStep();
  virtual ~C2SGobangStep();

  C2SGobangStep(const C2SGobangStep& from);

  inline C2SGobangStep& operator=(const C2SGobangStep& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  C2SGobangStep(C2SGobangStep&& from) noexcept
    : C2SGobangStep() {
    *this = ::std::move(from);
  }

  inline C2SGobangStep& operator=(C2SGobangStep&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const C2SGobangStep& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const C2SGobangStep* internal_default_instance() {
    return reinterpret_cast<const C2SGobangStep*>(
               &_C2SGobangStep_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(C2SGobangStep* other);
  friend void swap(C2SGobangStep& a, C2SGobangStep& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline C2SGobangStep* New() const PROTOBUF_FINAL { return New(NULL); }

  C2SGobangStep* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const C2SGobangStep& from);
  void MergeFrom(const C2SGobangStep& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(C2SGobangStep* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .gamepb.Point point = 1;
  bool has_point() const;
  void clear_point();
  static const int kPointFieldNumber = 1;
  const ::gamepb::Point& point() const;
  ::gamepb::Point* release_point();
  ::gamepb::Point* mutable_point();
  void set_allocated_point(::gamepb::Point* point);

  // @@protoc_insertion_point(class_scope:gamepb.C2SGobangStep)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::gamepb::Point* point_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsC2SGobangStepImpl();
};
// -------------------------------------------------------------------

class S2CGobangStep : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gamepb.S2CGobangStep) */ {
 public:
  S2CGobangStep();
  virtual ~S2CGobangStep();

  S2CGobangStep(const S2CGobangStep& from);

  inline S2CGobangStep& operator=(const S2CGobangStep& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  S2CGobangStep(S2CGobangStep&& from) noexcept
    : S2CGobangStep() {
    *this = ::std::move(from);
  }

  inline S2CGobangStep& operator=(S2CGobangStep&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const S2CGobangStep& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const S2CGobangStep* internal_default_instance() {
    return reinterpret_cast<const S2CGobangStep*>(
               &_S2CGobangStep_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(S2CGobangStep* other);
  friend void swap(S2CGobangStep& a, S2CGobangStep& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline S2CGobangStep* New() const PROTOBUF_FINAL { return New(NULL); }

  S2CGobangStep* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const S2CGobangStep& from);
  void MergeFrom(const S2CGobangStep& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(S2CGobangStep* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .gamepb.Error error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  const ::gamepb::Error& error() const;
  ::gamepb::Error* release_error();
  ::gamepb::Error* mutable_error();
  void set_allocated_error(::gamepb::Error* error);

  // .gamepb.GobangInfo gobangInfo = 2;
  bool has_gobanginfo() const;
  void clear_gobanginfo();
  static const int kGobangInfoFieldNumber = 2;
  const ::gamepb::GobangInfo& gobanginfo() const;
  ::gamepb::GobangInfo* release_gobanginfo();
  ::gamepb::GobangInfo* mutable_gobanginfo();
  void set_allocated_gobanginfo(::gamepb::GobangInfo* gobanginfo);

  // @@protoc_insertion_point(class_scope:gamepb.S2CGobangStep)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::gamepb::Error* error_;
  ::gamepb::GobangInfo* gobanginfo_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsS2CGobangStepImpl();
};
// -------------------------------------------------------------------

class C2SPing : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gamepb.C2SPing) */ {
 public:
  C2SPing();
  virtual ~C2SPing();

  C2SPing(const C2SPing& from);

  inline C2SPing& operator=(const C2SPing& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  C2SPing(C2SPing&& from) noexcept
    : C2SPing() {
    *this = ::std::move(from);
  }

  inline C2SPing& operator=(C2SPing&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const C2SPing& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const C2SPing* internal_default_instance() {
    return reinterpret_cast<const C2SPing*>(
               &_C2SPing_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(C2SPing* other);
  friend void swap(C2SPing& a, C2SPing& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline C2SPing* New() const PROTOBUF_FINAL { return New(NULL); }

  C2SPing* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const C2SPing& from);
  void MergeFrom(const C2SPing& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(C2SPing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:gamepb.C2SPing)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 timestamp_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsC2SPingImpl();
};
// -------------------------------------------------------------------

class S2CPing : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gamepb.S2CPing) */ {
 public:
  S2CPing();
  virtual ~S2CPing();

  S2CPing(const S2CPing& from);

  inline S2CPing& operator=(const S2CPing& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  S2CPing(S2CPing&& from) noexcept
    : S2CPing() {
    *this = ::std::move(from);
  }

  inline S2CPing& operator=(S2CPing&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const S2CPing& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const S2CPing* internal_default_instance() {
    return reinterpret_cast<const S2CPing*>(
               &_S2CPing_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(S2CPing* other);
  friend void swap(S2CPing& a, S2CPing& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline S2CPing* New() const PROTOBUF_FINAL { return New(NULL); }

  S2CPing* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const S2CPing& from);
  void MergeFrom(const S2CPing& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(S2CPing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .gamepb.Error error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  const ::gamepb::Error& error() const;
  ::gamepb::Error* release_error();
  ::gamepb::Error* mutable_error();
  void set_allocated_error(::gamepb::Error* error);

  // int64 timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:gamepb.S2CPing)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::gamepb::Error* error_;
  ::google::protobuf::int64 timestamp_;
  mutable int _cached_size_;
  friend struct ::protobuf_game_2eproto::TableStruct;
  friend void ::protobuf_game_2eproto::InitDefaultsS2CPingImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HelloRequest

// string name = 1;
inline void HelloRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HelloRequest::name() const {
  // @@protoc_insertion_point(field_get:gamepb.HelloRequest.name)
  return name_.GetNoArena();
}
inline void HelloRequest::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gamepb.HelloRequest.name)
}
#if LANG_CXX11
inline void HelloRequest::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gamepb.HelloRequest.name)
}
#endif
inline void HelloRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gamepb.HelloRequest.name)
}
inline void HelloRequest::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gamepb.HelloRequest.name)
}
inline ::std::string* HelloRequest::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:gamepb.HelloRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HelloRequest::release_name() {
  // @@protoc_insertion_point(field_release:gamepb.HelloRequest.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HelloRequest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:gamepb.HelloRequest.name)
}

// -------------------------------------------------------------------

// HelloReply

// string message = 1;
inline void HelloReply::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HelloReply::message() const {
  // @@protoc_insertion_point(field_get:gamepb.HelloReply.message)
  return message_.GetNoArena();
}
inline void HelloReply::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gamepb.HelloReply.message)
}
#if LANG_CXX11
inline void HelloReply::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gamepb.HelloReply.message)
}
#endif
inline void HelloReply::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gamepb.HelloReply.message)
}
inline void HelloReply::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gamepb.HelloReply.message)
}
inline ::std::string* HelloReply::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:gamepb.HelloReply.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HelloReply::release_message() {
  // @@protoc_insertion_point(field_release:gamepb.HelloReply.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HelloReply::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:gamepb.HelloReply.message)
}

// -------------------------------------------------------------------

// RouteNote

// .gamepb.Point location = 1;
inline bool RouteNote::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void RouteNote::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) {
    delete location_;
  }
  location_ = NULL;
}
inline const ::gamepb::Point& RouteNote::location() const {
  const ::gamepb::Point* p = location_;
  // @@protoc_insertion_point(field_get:gamepb.RouteNote.location)
  return p != NULL ? *p : *reinterpret_cast<const ::gamepb::Point*>(
      &::gamepb::_Point_default_instance_);
}
inline ::gamepb::Point* RouteNote::release_location() {
  // @@protoc_insertion_point(field_release:gamepb.RouteNote.location)
  
  ::gamepb::Point* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::gamepb::Point* RouteNote::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::gamepb::Point;
  }
  // @@protoc_insertion_point(field_mutable:gamepb.RouteNote.location)
  return location_;
}
inline void RouteNote::set_allocated_location(::gamepb::Point* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:gamepb.RouteNote.location)
}

// string message = 2;
inline void RouteNote::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RouteNote::message() const {
  // @@protoc_insertion_point(field_get:gamepb.RouteNote.message)
  return message_.GetNoArena();
}
inline void RouteNote::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gamepb.RouteNote.message)
}
#if LANG_CXX11
inline void RouteNote::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gamepb.RouteNote.message)
}
#endif
inline void RouteNote::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gamepb.RouteNote.message)
}
inline void RouteNote::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gamepb.RouteNote.message)
}
inline ::std::string* RouteNote::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:gamepb.RouteNote.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RouteNote::release_message() {
  // @@protoc_insertion_point(field_release:gamepb.RouteNote.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RouteNote::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:gamepb.RouteNote.message)
}

// -------------------------------------------------------------------

// Error

// .gamepb.ErrorType errorCode = 1;
inline void Error::clear_errorcode() {
  errorcode_ = 0;
}
inline ::gamepb::ErrorType Error::errorcode() const {
  // @@protoc_insertion_point(field_get:gamepb.Error.errorCode)
  return static_cast< ::gamepb::ErrorType >(errorcode_);
}
inline void Error::set_errorcode(::gamepb::ErrorType value) {
  
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:gamepb.Error.errorCode)
}

// string errorMsg = 2;
inline void Error::clear_errormsg() {
  errormsg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Error::errormsg() const {
  // @@protoc_insertion_point(field_get:gamepb.Error.errorMsg)
  return errormsg_.GetNoArena();
}
inline void Error::set_errormsg(const ::std::string& value) {
  
  errormsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gamepb.Error.errorMsg)
}
#if LANG_CXX11
inline void Error::set_errormsg(::std::string&& value) {
  
  errormsg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gamepb.Error.errorMsg)
}
#endif
inline void Error::set_errormsg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  errormsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gamepb.Error.errorMsg)
}
inline void Error::set_errormsg(const char* value, size_t size) {
  
  errormsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gamepb.Error.errorMsg)
}
inline ::std::string* Error::mutable_errormsg() {
  
  // @@protoc_insertion_point(field_mutable:gamepb.Error.errorMsg)
  return errormsg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error::release_errormsg() {
  // @@protoc_insertion_point(field_release:gamepb.Error.errorMsg)
  
  return errormsg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error::set_allocated_errormsg(::std::string* errormsg) {
  if (errormsg != NULL) {
    
  } else {
    
  }
  errormsg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errormsg);
  // @@protoc_insertion_point(field_set_allocated:gamepb.Error.errorMsg)
}

// -------------------------------------------------------------------

// Point

// int32 x = 1;
inline void Point::clear_x() {
  x_ = 0;
}
inline ::google::protobuf::int32 Point::x() const {
  // @@protoc_insertion_point(field_get:gamepb.Point.x)
  return x_;
}
inline void Point::set_x(::google::protobuf::int32 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:gamepb.Point.x)
}

// int32 y = 2;
inline void Point::clear_y() {
  y_ = 0;
}
inline ::google::protobuf::int32 Point::y() const {
  // @@protoc_insertion_point(field_get:gamepb.Point.y)
  return y_;
}
inline void Point::set_y(::google::protobuf::int32 value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:gamepb.Point.y)
}

// int32 Camp = 3;
inline void Point::clear_camp() {
  camp_ = 0;
}
inline ::google::protobuf::int32 Point::camp() const {
  // @@protoc_insertion_point(field_get:gamepb.Point.Camp)
  return camp_;
}
inline void Point::set_camp(::google::protobuf::int32 value) {
  
  camp_ = value;
  // @@protoc_insertion_point(field_set:gamepb.Point.Camp)
}

// -------------------------------------------------------------------

// ChessStep

// .gamepb.Point point = 1;
inline bool ChessStep::has_point() const {
  return this != internal_default_instance() && point_ != NULL;
}
inline void ChessStep::clear_point() {
  if (GetArenaNoVirtual() == NULL && point_ != NULL) {
    delete point_;
  }
  point_ = NULL;
}
inline const ::gamepb::Point& ChessStep::point() const {
  const ::gamepb::Point* p = point_;
  // @@protoc_insertion_point(field_get:gamepb.ChessStep.point)
  return p != NULL ? *p : *reinterpret_cast<const ::gamepb::Point*>(
      &::gamepb::_Point_default_instance_);
}
inline ::gamepb::Point* ChessStep::release_point() {
  // @@protoc_insertion_point(field_release:gamepb.ChessStep.point)
  
  ::gamepb::Point* temp = point_;
  point_ = NULL;
  return temp;
}
inline ::gamepb::Point* ChessStep::mutable_point() {
  
  if (point_ == NULL) {
    point_ = new ::gamepb::Point;
  }
  // @@protoc_insertion_point(field_mutable:gamepb.ChessStep.point)
  return point_;
}
inline void ChessStep::set_allocated_point(::gamepb::Point* point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete point_;
  }
  if (point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    
  } else {
    
  }
  point_ = point;
  // @@protoc_insertion_point(field_set_allocated:gamepb.ChessStep.point)
}

// int32 index = 2;
inline void ChessStep::clear_index() {
  index_ = 0;
}
inline ::google::protobuf::int32 ChessStep::index() const {
  // @@protoc_insertion_point(field_get:gamepb.ChessStep.index)
  return index_;
}
inline void ChessStep::set_index(::google::protobuf::int32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:gamepb.ChessStep.index)
}

// -------------------------------------------------------------------

// GobangInfo

// repeated .gamepb.ChessStep chessSteps = 1;
inline int GobangInfo::chesssteps_size() const {
  return chesssteps_.size();
}
inline void GobangInfo::clear_chesssteps() {
  chesssteps_.Clear();
}
inline const ::gamepb::ChessStep& GobangInfo::chesssteps(int index) const {
  // @@protoc_insertion_point(field_get:gamepb.GobangInfo.chessSteps)
  return chesssteps_.Get(index);
}
inline ::gamepb::ChessStep* GobangInfo::mutable_chesssteps(int index) {
  // @@protoc_insertion_point(field_mutable:gamepb.GobangInfo.chessSteps)
  return chesssteps_.Mutable(index);
}
inline ::gamepb::ChessStep* GobangInfo::add_chesssteps() {
  // @@protoc_insertion_point(field_add:gamepb.GobangInfo.chessSteps)
  return chesssteps_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::gamepb::ChessStep >*
GobangInfo::mutable_chesssteps() {
  // @@protoc_insertion_point(field_mutable_list:gamepb.GobangInfo.chessSteps)
  return &chesssteps_;
}
inline const ::google::protobuf::RepeatedPtrField< ::gamepb::ChessStep >&
GobangInfo::chesssteps() const {
  // @@protoc_insertion_point(field_list:gamepb.GobangInfo.chessSteps)
  return chesssteps_;
}

// -------------------------------------------------------------------

// C2SGobangStep

// .gamepb.Point point = 1;
inline bool C2SGobangStep::has_point() const {
  return this != internal_default_instance() && point_ != NULL;
}
inline void C2SGobangStep::clear_point() {
  if (GetArenaNoVirtual() == NULL && point_ != NULL) {
    delete point_;
  }
  point_ = NULL;
}
inline const ::gamepb::Point& C2SGobangStep::point() const {
  const ::gamepb::Point* p = point_;
  // @@protoc_insertion_point(field_get:gamepb.C2SGobangStep.point)
  return p != NULL ? *p : *reinterpret_cast<const ::gamepb::Point*>(
      &::gamepb::_Point_default_instance_);
}
inline ::gamepb::Point* C2SGobangStep::release_point() {
  // @@protoc_insertion_point(field_release:gamepb.C2SGobangStep.point)
  
  ::gamepb::Point* temp = point_;
  point_ = NULL;
  return temp;
}
inline ::gamepb::Point* C2SGobangStep::mutable_point() {
  
  if (point_ == NULL) {
    point_ = new ::gamepb::Point;
  }
  // @@protoc_insertion_point(field_mutable:gamepb.C2SGobangStep.point)
  return point_;
}
inline void C2SGobangStep::set_allocated_point(::gamepb::Point* point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete point_;
  }
  if (point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    
  } else {
    
  }
  point_ = point;
  // @@protoc_insertion_point(field_set_allocated:gamepb.C2SGobangStep.point)
}

// -------------------------------------------------------------------

// S2CGobangStep

// .gamepb.Error error = 1;
inline bool S2CGobangStep::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline void S2CGobangStep::clear_error() {
  if (GetArenaNoVirtual() == NULL && error_ != NULL) {
    delete error_;
  }
  error_ = NULL;
}
inline const ::gamepb::Error& S2CGobangStep::error() const {
  const ::gamepb::Error* p = error_;
  // @@protoc_insertion_point(field_get:gamepb.S2CGobangStep.error)
  return p != NULL ? *p : *reinterpret_cast<const ::gamepb::Error*>(
      &::gamepb::_Error_default_instance_);
}
inline ::gamepb::Error* S2CGobangStep::release_error() {
  // @@protoc_insertion_point(field_release:gamepb.S2CGobangStep.error)
  
  ::gamepb::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::gamepb::Error* S2CGobangStep::mutable_error() {
  
  if (error_ == NULL) {
    error_ = new ::gamepb::Error;
  }
  // @@protoc_insertion_point(field_mutable:gamepb.S2CGobangStep.error)
  return error_;
}
inline void S2CGobangStep::set_allocated_error(::gamepb::Error* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete error_;
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:gamepb.S2CGobangStep.error)
}

// .gamepb.GobangInfo gobangInfo = 2;
inline bool S2CGobangStep::has_gobanginfo() const {
  return this != internal_default_instance() && gobanginfo_ != NULL;
}
inline void S2CGobangStep::clear_gobanginfo() {
  if (GetArenaNoVirtual() == NULL && gobanginfo_ != NULL) {
    delete gobanginfo_;
  }
  gobanginfo_ = NULL;
}
inline const ::gamepb::GobangInfo& S2CGobangStep::gobanginfo() const {
  const ::gamepb::GobangInfo* p = gobanginfo_;
  // @@protoc_insertion_point(field_get:gamepb.S2CGobangStep.gobangInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::gamepb::GobangInfo*>(
      &::gamepb::_GobangInfo_default_instance_);
}
inline ::gamepb::GobangInfo* S2CGobangStep::release_gobanginfo() {
  // @@protoc_insertion_point(field_release:gamepb.S2CGobangStep.gobangInfo)
  
  ::gamepb::GobangInfo* temp = gobanginfo_;
  gobanginfo_ = NULL;
  return temp;
}
inline ::gamepb::GobangInfo* S2CGobangStep::mutable_gobanginfo() {
  
  if (gobanginfo_ == NULL) {
    gobanginfo_ = new ::gamepb::GobangInfo;
  }
  // @@protoc_insertion_point(field_mutable:gamepb.S2CGobangStep.gobangInfo)
  return gobanginfo_;
}
inline void S2CGobangStep::set_allocated_gobanginfo(::gamepb::GobangInfo* gobanginfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete gobanginfo_;
  }
  if (gobanginfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      gobanginfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gobanginfo, submessage_arena);
    }
    
  } else {
    
  }
  gobanginfo_ = gobanginfo;
  // @@protoc_insertion_point(field_set_allocated:gamepb.S2CGobangStep.gobangInfo)
}

// -------------------------------------------------------------------

// C2SPing

// int64 timestamp = 1;
inline void C2SPing::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 C2SPing::timestamp() const {
  // @@protoc_insertion_point(field_get:gamepb.C2SPing.timestamp)
  return timestamp_;
}
inline void C2SPing::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:gamepb.C2SPing.timestamp)
}

// -------------------------------------------------------------------

// S2CPing

// .gamepb.Error error = 1;
inline bool S2CPing::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline void S2CPing::clear_error() {
  if (GetArenaNoVirtual() == NULL && error_ != NULL) {
    delete error_;
  }
  error_ = NULL;
}
inline const ::gamepb::Error& S2CPing::error() const {
  const ::gamepb::Error* p = error_;
  // @@protoc_insertion_point(field_get:gamepb.S2CPing.error)
  return p != NULL ? *p : *reinterpret_cast<const ::gamepb::Error*>(
      &::gamepb::_Error_default_instance_);
}
inline ::gamepb::Error* S2CPing::release_error() {
  // @@protoc_insertion_point(field_release:gamepb.S2CPing.error)
  
  ::gamepb::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::gamepb::Error* S2CPing::mutable_error() {
  
  if (error_ == NULL) {
    error_ = new ::gamepb::Error;
  }
  // @@protoc_insertion_point(field_mutable:gamepb.S2CPing.error)
  return error_;
}
inline void S2CPing::set_allocated_error(::gamepb::Error* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete error_;
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:gamepb.S2CPing.error)
}

// int64 timestamp = 2;
inline void S2CPing::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 S2CPing::timestamp() const {
  // @@protoc_insertion_point(field_get:gamepb.S2CPing.timestamp)
  return timestamp_;
}
inline void S2CPing::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:gamepb.S2CPing.timestamp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace gamepb

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_game_2eproto__INCLUDED
